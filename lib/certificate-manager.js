import { readFileSync, writeFileSync, mkdirSync, existsSync, readdirSync, rmSync, renameSync, chmodSync } from "node:fs";
import { join } from "node:path";
import { createSecureContext } from "node:tls";
import { createHash } from "node:crypto";
import { hostname } from "node:os";
import forge from "node-forge";
import { log } from "./log.js";

const MAX_NETWORKS = 10;
const SERVER_YEARS = 2;

/**
 * CertificateManager handles multi-certificate SNI architecture for network mobility
 * - Auto-generates certificates for new networks
 * - Zero-downtime certificate updates via hot-reload
 * - Network-specific certificate management
 */
export class CertificateManager {
  constructor(dataDir, instanceName) {
    this.dataDir = dataDir;
    this.instanceName = instanceName;
    this.tlsDir = join(dataDir, "tls");
    this.networksDir = join(this.tlsDir, "networks");
    this.certCache = new Map(); // networkId -> SecureContext
    this.metadataCache = new Map(); // networkId -> metadata
  }

  /**
   * Initialize certificate manager - migrate old certs and load all network certs
   */
  async initialize() {
    // Ensure directories exist
    mkdirSync(this.networksDir, { recursive: true });

    // Migrate old single cert to default network if needed
    await this.migrateOldCert();

    // Load all network certificates
    await this.loadAllNetworks();

    log.info("Certificate manager initialized", {
      networks: this.metadataCache.size,
    });
  }

  /**
   * Migrate old single cert (tls/server.crt) to networks/default/
   */
  async migrateOldCert() {
    const oldCertPath = join(this.tlsDir, "server.crt");
    const oldKeyPath = join(this.tlsDir, "server.key");
    const defaultDir = join(this.networksDir, "default");

    // Check if old cert exists and default doesn't
    if (existsSync(oldCertPath) && !existsSync(defaultDir)) {
      log.info("Migrating single certificate to default network");

      mkdirSync(defaultDir, { recursive: true });

      // Copy cert and key to default network
      const certContent = readFileSync(oldCertPath);
      const keyContent = readFileSync(oldKeyPath);

      writeFileSync(join(defaultDir, "server.crt"), certContent);
      writeFileSync(join(defaultDir, "server.key"), keyContent, { mode: 0o600 });

      // Generate metadata from existing cert
      try {
        const certPem = readFileSync(oldCertPath, "utf-8");
        const cert = forge.pki.certificateFromPem(certPem);

        // Extract IPs from SANs
        const sanExt = cert.getExtension("subjectAltName");
        const ips = [];
        if (sanExt && sanExt.altNames) {
          for (const altName of sanExt.altNames) {
            if (altName.type === 7) ips.push(altName.ip);
          }
        }

        const metadata = {
          networkId: "default",
          ips: ips.filter(ip => !ip.startsWith("127.") && ip !== "::1"),
          createdAt: cert.validity.notBefore.toISOString(),
          lastUsedAt: new Date().toISOString(),
          label: "Default Network",
          autoGenerated: false,
        };

        this.writeMetadata(defaultDir, metadata);
        log.info("Migration complete", { ips: metadata.ips });
      } catch (error) {
        log.error("Failed to extract metadata from old cert", { error: error.message });
      }

      // Keep old files for safety (don't delete them)
    }
  }

  /**
   * Load all network certificates into cache
   */
  async loadAllNetworks() {
    if (!existsSync(this.networksDir)) return;

    const networks = readdirSync(this.networksDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name);

    for (const networkId of networks) {
      try {
        const networkDir = join(this.networksDir, networkId);
        const metadata = this.readMetadata(networkDir);

        if (metadata) {
          this.metadataCache.set(networkId, metadata);
          // Pre-load secure context
          this.loadSecureContext(networkId);
        }
      } catch (error) {
        log.warn(`Failed to load network ${networkId}`, { error: error.message });
      }
    }
  }

  /**
   * Get SNI callback for HTTPS server
   * @returns {Function} SNI callback (servername, callback) => void
   */
  getSNICallback() {
    return async (servername, callback) => {
      try {
        // Resolve servername to IP (it might be IP or hostname)
        const ip = this.resolveToIp(servername);
        const networkId = this.getNetworkIdForIp(ip);

        // Get or create certificate for this network
        let context = this.certCache.get(networkId);
        if (!context) {
          await this.ensureNetworkCert(ip);
          context = this.loadSecureContext(networkId);
        }

        // Update lastUsedAt
        await this.touchNetworkCert(networkId);

        callback(null, context);
      } catch (error) {
        log.error("SNI callback error", { servername, error: error.message });
        // Fall back to default network
        const defaultContext = this.certCache.get("default");
        callback(null, defaultContext || null);
      }
    };
  }

  /**
   * Get secure context for a network
   * @param {string} networkId - Network ID
   * @returns {SecureContext} TLS secure context
   */
  getSecureContext(networkId) {
    let context = this.certCache.get(networkId);
    if (!context) {
      context = this.loadSecureContext(networkId);
    }
    return context;
  }

  /**
   * Load secure context from disk
   * @param {string} networkId - Network ID
   * @returns {SecureContext} TLS secure context
   */
  loadSecureContext(networkId) {
    const networkDir = join(this.networksDir, networkId);
    const certPath = join(networkDir, "server.crt");
    const keyPath = join(networkDir, "server.key");

    if (!existsSync(certPath) || !existsSync(keyPath)) {
      throw new Error(`Certificate not found for network ${networkId}`);
    }

    const cert = readFileSync(certPath);
    const key = readFileSync(keyPath);

    const context = createSecureContext({ cert, key });
    this.certCache.set(networkId, context);

    return context;
  }

  /**
   * Get default cert/key for HTTPS server fallback (used when no SNI is sent, e.g. IP connections)
   * @returns {{ cert: Buffer, key: Buffer }} Default certificate and key
   */
  getDefaultCertKey() {
    const defaultDir = join(this.networksDir, "default");
    const certPath = join(defaultDir, "server.crt");
    const keyPath = join(defaultDir, "server.key");

    return {
      cert: readFileSync(certPath),
      key: readFileSync(keyPath),
    };
  }

  /**
   * List all networks with metadata
   * @returns {Array} Array of network metadata objects
   */
  async listNetworks() {
    const networks = [];

    for (const [networkId, metadata] of this.metadataCache.entries()) {
      networks.push({ ...metadata });
    }

    // Sort by lastUsedAt descending
    networks.sort((a, b) => new Date(b.lastUsedAt) - new Date(a.lastUsedAt));

    return networks;
  }

  /**
   * Ensure certificate exists for a network (auto-generate if missing)
   * @param {string} ip - IP address
   * @returns {string} Network ID
   */
  async ensureNetworkCert(ip) {
    const networkId = this.getNetworkIdForIp(ip);
    const networkDir = join(this.networksDir, networkId);

    // Check if cert already exists
    if (existsSync(join(networkDir, "server.crt"))) {
      return networkId;
    }

    // Check network limit
    if (this.metadataCache.size >= MAX_NETWORKS && !this.metadataCache.has(networkId)) {
      throw new Error(`Maximum of ${MAX_NETWORKS} networks reached`);
    }

    log.info("Auto-generating certificate for new network", { ip, networkId });

    // Create network directory
    mkdirSync(networkDir, { recursive: true });

    // Load CA
    const caCertPath = join(this.tlsDir, "ca.crt");
    const caKeyPath = join(this.tlsDir, "ca.key");

    if (!existsSync(caCertPath) || !existsSync(caKeyPath)) {
      throw new Error("CA certificate not found");
    }

    const caCertPem = readFileSync(caCertPath, "utf-8");
    const caKeyPem = readFileSync(caKeyPath, "utf-8");
    const caCert = forge.pki.certificateFromPem(caCertPem);
    const caKey = forge.pki.privateKeyFromPem(caKeyPem);

    // Generate network certificate with subnet IPs
    const subnetIps = this.getSubnetIps(ip);
    const { certPem, keyPem } = this.generateNetworkCert(caCert, caKey, subnetIps);

    // Write cert and key atomically
    const certTmp = join(networkDir, "server.crt.tmp");
    const keyTmp = join(networkDir, "server.key.tmp");

    writeFileSync(certTmp, certPem);
    writeFileSync(keyTmp, keyPem, { mode: 0o600 });

    renameSync(certTmp, join(networkDir, "server.crt"));
    renameSync(keyTmp, join(networkDir, "server.key"));

    // Ensure correct permissions
    try {
      chmodSync(join(networkDir, "server.key"), 0o600);
    } catch {
      // Best-effort on platforms that don't support chmod
    }

    // Write metadata
    const hostName = hostname();
    const subnet = ip.split('.').slice(0, 3).join('.');
    const metadata = {
      networkId,
      ips: [ip],
      createdAt: new Date().toISOString(),
      lastUsedAt: new Date().toISOString(),
      label: `${hostName} (${subnet}.*)`,
      autoGenerated: true,
    };

    this.writeMetadata(networkDir, metadata);
    this.metadataCache.set(networkId, metadata);

    // Load into cache
    this.loadSecureContext(networkId);

    return networkId;
  }

  /**
   * Regenerate certificate for a specific network
   * @param {string} networkId - Network ID
   */
  async regenerateNetwork(networkId) {
    const networkDir = join(this.networksDir, networkId);
    const metadata = this.metadataCache.get(networkId);

    if (!metadata) {
      throw new Error(`Network ${networkId} not found`);
    }

    log.info("Regenerating certificate for network", { networkId });

    // Load CA
    const caCertPath = join(this.tlsDir, "ca.crt");
    const caKeyPath = join(this.tlsDir, "ca.key");
    const caCertPem = readFileSync(caCertPath, "utf-8");
    const caKeyPem = readFileSync(caKeyPath, "utf-8");
    const caCert = forge.pki.certificateFromPem(caCertPem);
    const caKey = forge.pki.privateKeyFromPem(caKeyPem);

    // Get subnet IPs based on existing metadata
    const primaryIp = metadata.ips[0];
    const subnetIps = this.getSubnetIps(primaryIp);

    // Generate new certificate
    const { certPem, keyPem } = this.generateNetworkCert(caCert, caKey, subnetIps);

    // Write atomically
    const certTmp = join(networkDir, "server.crt.tmp");
    const keyTmp = join(networkDir, "server.key.tmp");

    writeFileSync(certTmp, certPem);
    writeFileSync(keyTmp, keyPem, { mode: 0o600 });

    renameSync(certTmp, join(networkDir, "server.crt"));
    renameSync(keyTmp, join(networkDir, "server.key"));

    try {
      chmodSync(join(networkDir, "server.key"), 0o600);
    } catch {
      // Best-effort
    }

    // Update metadata
    metadata.lastUsedAt = new Date().toISOString();
    this.writeMetadata(networkDir, metadata);
  }

  /**
   * Revoke (delete) a network certificate
   * @param {string} networkId - Network ID
   */
  async revokeNetwork(networkId) {
    if (networkId === "default") {
      throw new Error("Cannot revoke default network");
    }

    const networkDir = join(this.networksDir, networkId);

    if (!existsSync(networkDir)) {
      throw new Error(`Network ${networkId} not found`);
    }

    log.info("Revoking network certificate", { networkId });

    // Remove from cache
    this.certCache.delete(networkId);
    this.metadataCache.delete(networkId);

    // Delete directory
    rmSync(networkDir, { recursive: true, force: true });
  }

  /**
   * Update network label
   * @param {string} networkId - Network ID
   * @param {string} label - New label
   */
  async updateNetworkLabel(networkId, label) {
    const networkDir = join(this.networksDir, networkId);
    const metadata = this.metadataCache.get(networkId);

    if (!metadata) {
      throw new Error(`Network ${networkId} not found`);
    }

    metadata.label = label;
    metadata.lastUsedAt = new Date().toISOString();

    this.writeMetadata(networkDir, metadata);
    this.metadataCache.set(networkId, metadata);
  }

  /**
   * Hot-reload certificate (invalidate cache and reload from disk)
   * @param {string} networkId - Network ID
   */
  async reloadCertificate(networkId) {
    log.info("Hot-reloading certificate", { networkId });

    // Invalidate cache
    this.certCache.delete(networkId);

    // Reload from disk
    this.loadSecureContext(networkId);

    // Update metadata cache
    const networkDir = join(this.networksDir, networkId);
    const metadata = this.readMetadata(networkDir);
    if (metadata) {
      this.metadataCache.set(networkId, metadata);
    }
  }

  /**
   * Update lastUsedAt timestamp for a network
   * @param {string} networkId - Network ID
   */
  async touchNetworkCert(networkId) {
    const metadata = this.metadataCache.get(networkId);
    if (!metadata) return;

    // Only update if more than 1 hour old to avoid excessive writes
    const lastUsed = new Date(metadata.lastUsedAt);
    const now = new Date();
    if (now - lastUsed < 3600000) return;

    metadata.lastUsedAt = now.toISOString();
    const networkDir = join(this.networksDir, networkId);
    this.writeMetadata(networkDir, metadata);
  }

  /**
   * Get network ID from IP address (based on subnet)
   * @param {string} ip - IP address
   * @returns {string} Network ID
   */
  getNetworkIdForIp(ip) {
    // For default/localhost, use "default"
    if (ip === "127.0.0.1" || ip === "::1" || ip === "localhost") {
      return "default";
    }

    // Extract subnet (e.g., 192.168.1.x -> 192-168-1-0)
    const parts = ip.split('.');
    if (parts.length === 4) {
      const subnet = `${parts[0]}-${parts[1]}-${parts[2]}-0`;
      return `net-${subnet}`;
    }

    // IPv6 or other - use hash
    const hash = createHash('sha256').update(ip).digest('hex').slice(0, 8);
    return `net-${hash}`;
  }

  /**
   * Get all IPs in a subnet (for certificate SANs)
   * @param {string} ip - Single IP address
   * @returns {Array} Array of IPs in subnet
   */
  getSubnetIps(ip) {
    const parts = ip.split('.');
    if (parts.length !== 4) return [ip];

    // Just return the single IP - we'll only add the specific IP to SANs
    // (not all 254 IPs in subnet)
    return [ip];
  }

  /**
   * Resolve servername to IP (might be hostname or IP)
   * @param {string} servername - Server name from SNI
   * @returns {string} IP address
   */
  resolveToIp(servername) {
    // If it's already an IP, return it
    if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(servername)) {
      return servername;
    }

    // For localhost/hostname, return "localhost"
    return "localhost";
  }

  /**
   * Generate network-specific certificate
   * @param {object} caCert - CA certificate
   * @param {object} caKey - CA private key
   * @param {Array} ips - IPs to include in SANs
   * @returns {object} { certPem, keyPem }
   */
  generateNetworkCert(caCert, caKey, ips) {
    const keys = forge.pki.rsa.generateKeyPair(2048);
    const cert = forge.pki.createCertificate();

    cert.publicKey = keys.publicKey;
    cert.serialNumber = Math.floor(Math.random() * 1000000).toString();
    cert.validity.notBefore = new Date();
    cert.validity.notAfter = new Date();
    cert.validity.notAfter.setFullYear(
      cert.validity.notBefore.getFullYear() + SERVER_YEARS,
    );

    const attrs = [
      { name: "organizationName", value: this.instanceName },
      { name: "commonName", value: "localhost" },
    ];
    cert.setSubject(attrs);
    cert.setIssuer(caCert.subject.attributes);

    // Build SANs: localhost, loopback, network IPs
    const altNames = [
      { type: 2, value: "localhost" },
      { type: 7, ip: "127.0.0.1" },
      { type: 7, ip: "::1" },
    ];

    // Add network IPs
    for (const ip of ips) {
      if (ip !== "127.0.0.1" && ip !== "::1") {
        altNames.push({ type: 7, ip });
      }
    }

    cert.setExtensions([
      { name: "basicConstraints", cA: false },
      {
        name: "keyUsage",
        digitalSignature: true,
        keyEncipherment: true,
      },
      {
        name: "extKeyUsage",
        serverAuth: true,
      },
      {
        name: "subjectAltName",
        altNames,
      },
    ]);

    cert.sign(caKey, forge.md.sha256.create());

    return {
      certPem: forge.pki.certificateToPem(cert),
      keyPem: forge.pki.privateKeyToPem(keys.privateKey),
    };
  }

  /**
   * Read metadata.json from network directory
   * @param {string} networkDir - Network directory path
   * @returns {object|null} Metadata object or null if not found
   */
  readMetadata(networkDir) {
    const metadataPath = join(networkDir, "metadata.json");
    if (!existsSync(metadataPath)) return null;

    try {
      const content = readFileSync(metadataPath, "utf-8");
      return JSON.parse(content);
    } catch (error) {
      log.warn("Failed to read metadata", { path: metadataPath, error: error.message });
      return null;
    }
  }

  /**
   * Write metadata.json to network directory (atomic)
   * @param {string} networkDir - Network directory path
   * @param {object} metadata - Metadata object
   */
  writeMetadata(networkDir, metadata) {
    const metadataPath = join(networkDir, "metadata.json");
    const tmpPath = join(networkDir, "metadata.json.tmp");

    writeFileSync(tmpPath, JSON.stringify(metadata, null, 2));
    renameSync(tmpPath, metadataPath);
  }
}
